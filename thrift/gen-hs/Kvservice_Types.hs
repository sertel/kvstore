{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -fno-warn-missing-fields #-}
{-# OPTIONS_GHC -fno-warn-missing-signatures #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-----------------------------------------------------------------
-- Autogenerated by Thrift Compiler (0.9.3)                      --
--                                                             --
-- DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING --
-----------------------------------------------------------------

module Kvservice_Types where
import Prelude (($), (.), (>>=), (==), (++))
import qualified Prelude as P
import qualified Control.Exception as X
import qualified Control.Monad as M ( liftM, ap, when )
import Data.Functor ( (<$>) )
import qualified Data.ByteString.Lazy as LBS
import qualified Data.Hashable as H
import qualified Data.Int as I
import qualified Data.Maybe as M (catMaybes)
import qualified Data.Text.Lazy.Encoding as E ( decodeUtf8, encodeUtf8 )
import qualified Data.Text.Lazy as LT
import qualified GHC.Generics as G (Generic)
import qualified Data.Typeable as TY ( Typeable )
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set
import qualified Data.Vector as Vector
import qualified Test.QuickCheck.Arbitrary as QC ( Arbitrary(..) )
import qualified Test.QuickCheck as QC ( elements )

import qualified Thrift as T
import qualified Thrift.Types as T
import qualified Thrift.Arbitraries as T


data Operation = READ|SCAN|UPDATE|INSERT|DELETE  deriving (P.Show, P.Eq, G.Generic, TY.Typeable, P.Ord, P.Bounded)
instance P.Enum Operation where
  fromEnum t = case t of
    READ -> 1
    SCAN -> 2
    UPDATE -> 3
    INSERT -> 4
    DELETE -> 5
  toEnum t = case t of
    1 -> READ
    2 -> SCAN
    3 -> UPDATE
    4 -> INSERT
    5 -> DELETE
    _ -> X.throw T.ThriftException
instance H.Hashable Operation where
  hashWithSalt salt = H.hashWithSalt salt P.. P.fromEnum
instance QC.Arbitrary Operation where
  arbitrary = QC.elements (P.enumFromTo P.minBound P.maxBound)
data KVRequest = KVRequest  { kVRequest_op :: Operation
  , kVRequest_table :: LT.Text
  , kVRequest_key :: LT.Text
  , kVRequest_fields :: P.Maybe (Set.HashSet LT.Text)
  , kVRequest_recordCount :: P.Maybe I.Int32
  , kVRequest_values :: P.Maybe (Map.HashMap LT.Text LT.Text)
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KVRequest where
  hashWithSalt salt record = salt   `H.hashWithSalt` kVRequest_op record   `H.hashWithSalt` kVRequest_table record   `H.hashWithSalt` kVRequest_key record   `H.hashWithSalt` kVRequest_fields record   `H.hashWithSalt` kVRequest_recordCount record   `H.hashWithSalt` kVRequest_values record  
instance QC.Arbitrary KVRequest where 
  arbitrary = M.liftM KVRequest (QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_KVRequest = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KVRequest{kVRequest_op = kVRequest_op obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_op = kVRequest_op obj}
    , if obj == default_KVRequest{kVRequest_table = kVRequest_table obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_table = kVRequest_table obj}
    , if obj == default_KVRequest{kVRequest_key = kVRequest_key obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_key = kVRequest_key obj}
    , if obj == default_KVRequest{kVRequest_fields = kVRequest_fields obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_fields = kVRequest_fields obj}
    , if obj == default_KVRequest{kVRequest_recordCount = kVRequest_recordCount obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_recordCount = kVRequest_recordCount obj}
    , if obj == default_KVRequest{kVRequest_values = kVRequest_values obj} then P.Nothing else P.Just $ default_KVRequest{kVRequest_values = kVRequest_values obj}
    ]
from_KVRequest :: KVRequest -> T.ThriftVal
from_KVRequest record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v2 -> P.Just (1, ("op",T.TI32 $ P.fromIntegral $ P.fromEnum _v2))) $ kVRequest_op record
  , (\_v2 -> P.Just (2, ("table",T.TString $ E.encodeUtf8 _v2))) $ kVRequest_table record
  , (\_v2 -> P.Just (3, ("key",T.TString $ E.encodeUtf8 _v2))) $ kVRequest_key record
  , (\_v2 -> (4, ("fields",T.TSet T.T_STRING $ P.map (\_v4 -> T.TString $ E.encodeUtf8 _v4) $ Set.toList _v2))) <$> kVRequest_fields record
  , (\_v2 -> (5, ("recordCount",T.TI32 _v2))) <$> kVRequest_recordCount record
  , (\_v2 -> (6, ("values",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k5,_v6) -> (T.TString $ E.encodeUtf8 _k5, T.TString $ E.encodeUtf8 _v6)) $ Map.toList _v2))) <$> kVRequest_values record
  ]
write_KVRequest :: (T.Protocol p, T.Transport t) => p t -> KVRequest -> P.IO ()
write_KVRequest oprot record = T.writeVal oprot $ from_KVRequest record
encode_KVRequest :: (T.Protocol p, T.Transport t) => p t -> KVRequest -> LBS.ByteString
encode_KVRequest oprot record = T.serializeVal oprot $ from_KVRequest record
to_KVRequest :: T.ThriftVal -> KVRequest
to_KVRequest (T.TStruct fields) = KVRequest{
  kVRequest_op = P.maybe (kVRequest_op default_KVRequest) (\(_,_val8) -> (case _val8 of {T.TI32 _val9 -> P.toEnum $ P.fromIntegral _val9; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  kVRequest_table = P.maybe (kVRequest_table default_KVRequest) (\(_,_val8) -> (case _val8 of {T.TString _val10 -> E.decodeUtf8 _val10; _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  kVRequest_key = P.maybe (kVRequest_key default_KVRequest) (\(_,_val8) -> (case _val8 of {T.TString _val11 -> E.decodeUtf8 _val11; _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  kVRequest_fields = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TSet _ _val12 -> (Set.fromList $ P.map (\_v13 -> (case _v13 of {T.TString _val14 -> E.decodeUtf8 _val14; _ -> P.error "wrong type"})) _val12); _ -> P.error "wrong type"})) (Map.lookup (4) fields),
  kVRequest_recordCount = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TI32 _val15 -> _val15; _ -> P.error "wrong type"})) (Map.lookup (5) fields),
  kVRequest_values = P.maybe (P.Nothing) (\(_,_val8) -> P.Just (case _val8 of {T.TMap _ _ _val16 -> (Map.fromList $ P.map (\(_k18,_v17) -> ((case _k18 of {T.TString _val19 -> E.decodeUtf8 _val19; _ -> P.error "wrong type"}),(case _v17 of {T.TString _val20 -> E.decodeUtf8 _val20; _ -> P.error "wrong type"}))) _val16); _ -> P.error "wrong type"})) (Map.lookup (6) fields)
  }
to_KVRequest _ = P.error "not a struct"
read_KVRequest :: (T.Transport t, T.Protocol p) => p t -> P.IO KVRequest
read_KVRequest iprot = to_KVRequest <$> T.readVal iprot (T.T_STRUCT typemap_KVRequest)
decode_KVRequest :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KVRequest
decode_KVRequest iprot bs = to_KVRequest $ T.deserializeVal iprot (T.T_STRUCT typemap_KVRequest) bs
typemap_KVRequest :: T.TypeMap
typemap_KVRequest = Map.fromList [(1,("op",T.T_I32)),(2,("table",T.T_STRING)),(3,("key",T.T_STRING)),(4,("fields",(T.T_SET T.T_STRING))),(5,("recordCount",T.T_I32)),(6,("values",(T.T_MAP T.T_STRING T.T_STRING)))]
default_KVRequest :: KVRequest
default_KVRequest = KVRequest{
  kVRequest_op = (P.toEnum 0),
  kVRequest_table = "",
  kVRequest_key = "",
  kVRequest_fields = P.Nothing,
  kVRequest_recordCount = P.Nothing,
  kVRequest_values = P.Nothing}
data KVResponse = KVResponse  { kVResponse_op :: Operation
  , kVResponse_values :: P.Maybe (Map.HashMap LT.Text LT.Text)
  , kVResponse_scannedValues :: P.Maybe (Vector.Vector (Map.HashMap LT.Text LT.Text))
  , kVResponse_failure :: P.Maybe LT.Text
  } deriving (P.Show,P.Eq,G.Generic,TY.Typeable)
instance H.Hashable KVResponse where
  hashWithSalt salt record = salt   `H.hashWithSalt` kVResponse_op record   `H.hashWithSalt` kVResponse_values record   `H.hashWithSalt` kVResponse_scannedValues record   `H.hashWithSalt` kVResponse_failure record  
instance QC.Arbitrary KVResponse where 
  arbitrary = M.liftM KVResponse (QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
          `M.ap`(M.liftM P.Just QC.arbitrary)
  shrink obj | obj == default_KVResponse = []
             | P.otherwise = M.catMaybes
    [ if obj == default_KVResponse{kVResponse_op = kVResponse_op obj} then P.Nothing else P.Just $ default_KVResponse{kVResponse_op = kVResponse_op obj}
    , if obj == default_KVResponse{kVResponse_values = kVResponse_values obj} then P.Nothing else P.Just $ default_KVResponse{kVResponse_values = kVResponse_values obj}
    , if obj == default_KVResponse{kVResponse_scannedValues = kVResponse_scannedValues obj} then P.Nothing else P.Just $ default_KVResponse{kVResponse_scannedValues = kVResponse_scannedValues obj}
    , if obj == default_KVResponse{kVResponse_failure = kVResponse_failure obj} then P.Nothing else P.Just $ default_KVResponse{kVResponse_failure = kVResponse_failure obj}
    ]
from_KVResponse :: KVResponse -> T.ThriftVal
from_KVResponse record = T.TStruct $ Map.fromList $ M.catMaybes
  [ (\_v23 -> P.Just (1, ("op",T.TI32 $ P.fromIntegral $ P.fromEnum _v23))) $ kVResponse_op record
  , (\_v23 -> (2, ("values",T.TMap T.T_STRING T.T_STRING $ P.map (\(_k24,_v25) -> (T.TString $ E.encodeUtf8 _k24, T.TString $ E.encodeUtf8 _v25)) $ Map.toList _v23))) <$> kVResponse_values record
  , (\_v23 -> (3, ("scannedValues",T.TList (T.T_MAP T.T_STRING T.T_STRING) $ P.map (\_v27 -> T.TMap T.T_STRING T.T_STRING $ P.map (\(_k28,_v29) -> (T.TString $ E.encodeUtf8 _k28, T.TString $ E.encodeUtf8 _v29)) $ Map.toList _v27) $ Vector.toList _v23))) <$> kVResponse_scannedValues record
  , (\_v23 -> (4, ("failure",T.TString $ E.encodeUtf8 _v23))) <$> kVResponse_failure record
  ]
write_KVResponse :: (T.Protocol p, T.Transport t) => p t -> KVResponse -> P.IO ()
write_KVResponse oprot record = T.writeVal oprot $ from_KVResponse record
encode_KVResponse :: (T.Protocol p, T.Transport t) => p t -> KVResponse -> LBS.ByteString
encode_KVResponse oprot record = T.serializeVal oprot $ from_KVResponse record
to_KVResponse :: T.ThriftVal -> KVResponse
to_KVResponse (T.TStruct fields) = KVResponse{
  kVResponse_op = P.maybe (kVResponse_op default_KVResponse) (\(_,_val31) -> (case _val31 of {T.TI32 _val32 -> P.toEnum $ P.fromIntegral _val32; _ -> P.error "wrong type"})) (Map.lookup (1) fields),
  kVResponse_values = P.maybe (P.Nothing) (\(_,_val31) -> P.Just (case _val31 of {T.TMap _ _ _val33 -> (Map.fromList $ P.map (\(_k35,_v34) -> ((case _k35 of {T.TString _val36 -> E.decodeUtf8 _val36; _ -> P.error "wrong type"}),(case _v34 of {T.TString _val37 -> E.decodeUtf8 _val37; _ -> P.error "wrong type"}))) _val33); _ -> P.error "wrong type"})) (Map.lookup (2) fields),
  kVResponse_scannedValues = P.maybe (P.Nothing) (\(_,_val31) -> P.Just (case _val31 of {T.TList _ _val38 -> (Vector.fromList $ P.map (\_v39 -> (case _v39 of {T.TMap _ _ _val40 -> (Map.fromList $ P.map (\(_k42,_v41) -> ((case _k42 of {T.TString _val43 -> E.decodeUtf8 _val43; _ -> P.error "wrong type"}),(case _v41 of {T.TString _val44 -> E.decodeUtf8 _val44; _ -> P.error "wrong type"}))) _val40); _ -> P.error "wrong type"})) _val38); _ -> P.error "wrong type"})) (Map.lookup (3) fields),
  kVResponse_failure = P.maybe (P.Nothing) (\(_,_val31) -> P.Just (case _val31 of {T.TString _val45 -> E.decodeUtf8 _val45; _ -> P.error "wrong type"})) (Map.lookup (4) fields)
  }
to_KVResponse _ = P.error "not a struct"
read_KVResponse :: (T.Transport t, T.Protocol p) => p t -> P.IO KVResponse
read_KVResponse iprot = to_KVResponse <$> T.readVal iprot (T.T_STRUCT typemap_KVResponse)
decode_KVResponse :: (T.Protocol p, T.Transport t) => p t -> LBS.ByteString -> KVResponse
decode_KVResponse iprot bs = to_KVResponse $ T.deserializeVal iprot (T.T_STRUCT typemap_KVResponse) bs
typemap_KVResponse :: T.TypeMap
typemap_KVResponse = Map.fromList [(1,("op",T.T_I32)),(2,("values",(T.T_MAP T.T_STRING T.T_STRING))),(3,("scannedValues",(T.T_LIST (T.T_MAP T.T_STRING T.T_STRING)))),(4,("failure",T.T_STRING))]
default_KVResponse :: KVResponse
default_KVResponse = KVResponse{
  kVResponse_op = (P.toEnum 0),
  kVResponse_values = P.Nothing,
  kVResponse_scannedValues = P.Nothing,
  kVResponse_failure = P.Nothing}
